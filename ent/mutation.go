// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/indikay/wallet-service/ent/currencyrate"
	"github.com/indikay/wallet-service/ent/ico"
	"github.com/indikay/wallet-service/ent/icocoupon"
	"github.com/indikay/wallet-service/ent/icohistory"
	"github.com/indikay/wallet-service/ent/icoround"
	"github.com/indikay/wallet-service/ent/predicate"
	"github.com/indikay/wallet-service/ent/transaction"
	"github.com/indikay/wallet-service/ent/userwallet"
	"github.com/rs/xid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCurrencyRate = "CurrencyRate"
	TypeIco          = "Ico"
	TypeIcoCoupon    = "IcoCoupon"
	TypeIcoHistory   = "IcoHistory"
	TypeIcoRound     = "IcoRound"
	TypeTransaction  = "Transaction"
	TypeUserWallet   = "UserWallet"
)

// CurrencyRateMutation represents an operation that mutates the CurrencyRate nodes in the graph.
type CurrencyRateMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	symbol        *string
	rate          *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CurrencyRate, error)
	predicates    []predicate.CurrencyRate
}

var _ ent.Mutation = (*CurrencyRateMutation)(nil)

// currencyrateOption allows management of the mutation configuration using functional options.
type currencyrateOption func(*CurrencyRateMutation)

// newCurrencyRateMutation creates new mutation for the CurrencyRate entity.
func newCurrencyRateMutation(c config, op Op, opts ...currencyrateOption) *CurrencyRateMutation {
	m := &CurrencyRateMutation{
		config:        c,
		op:            op,
		typ:           TypeCurrencyRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCurrencyRateID sets the ID field of the mutation.
func withCurrencyRateID(id int) currencyrateOption {
	return func(m *CurrencyRateMutation) {
		var (
			err   error
			once  sync.Once
			value *CurrencyRate
		)
		m.oldValue = func(ctx context.Context) (*CurrencyRate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CurrencyRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCurrencyRate sets the old CurrencyRate of the mutation.
func withCurrencyRate(node *CurrencyRate) currencyrateOption {
	return func(m *CurrencyRateMutation) {
		m.oldValue = func(context.Context) (*CurrencyRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CurrencyRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CurrencyRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CurrencyRateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CurrencyRateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CurrencyRate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CurrencyRateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CurrencyRateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CurrencyRate entity.
// If the CurrencyRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyRateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CurrencyRateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CurrencyRateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CurrencyRateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CurrencyRate entity.
// If the CurrencyRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyRateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CurrencyRateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSymbol sets the "symbol" field.
func (m *CurrencyRateMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *CurrencyRateMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the CurrencyRate entity.
// If the CurrencyRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyRateMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *CurrencyRateMutation) ResetSymbol() {
	m.symbol = nil
}

// SetRate sets the "rate" field.
func (m *CurrencyRateMutation) SetRate(s string) {
	m.rate = &s
}

// Rate returns the value of the "rate" field in the mutation.
func (m *CurrencyRateMutation) Rate() (r string, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the CurrencyRate entity.
// If the CurrencyRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyRateMutation) OldRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// ResetRate resets all changes to the "rate" field.
func (m *CurrencyRateMutation) ResetRate() {
	m.rate = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *CurrencyRateMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *CurrencyRateMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the CurrencyRate entity.
// If the CurrencyRate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyRateMutation) OldExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *CurrencyRateMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[currencyrate.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *CurrencyRateMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[currencyrate.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *CurrencyRateMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, currencyrate.FieldExpiredAt)
}

// Where appends a list predicates to the CurrencyRateMutation builder.
func (m *CurrencyRateMutation) Where(ps ...predicate.CurrencyRate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CurrencyRateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CurrencyRateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CurrencyRate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CurrencyRateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CurrencyRateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CurrencyRate).
func (m *CurrencyRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CurrencyRateMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, currencyrate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, currencyrate.FieldUpdatedAt)
	}
	if m.symbol != nil {
		fields = append(fields, currencyrate.FieldSymbol)
	}
	if m.rate != nil {
		fields = append(fields, currencyrate.FieldRate)
	}
	if m.expired_at != nil {
		fields = append(fields, currencyrate.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CurrencyRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case currencyrate.FieldCreatedAt:
		return m.CreatedAt()
	case currencyrate.FieldUpdatedAt:
		return m.UpdatedAt()
	case currencyrate.FieldSymbol:
		return m.Symbol()
	case currencyrate.FieldRate:
		return m.Rate()
	case currencyrate.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CurrencyRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case currencyrate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case currencyrate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case currencyrate.FieldSymbol:
		return m.OldSymbol(ctx)
	case currencyrate.FieldRate:
		return m.OldRate(ctx)
	case currencyrate.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown CurrencyRate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case currencyrate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case currencyrate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case currencyrate.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case currencyrate.FieldRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case currencyrate.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown CurrencyRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CurrencyRateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CurrencyRateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CurrencyRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CurrencyRateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(currencyrate.FieldExpiredAt) {
		fields = append(fields, currencyrate.FieldExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CurrencyRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CurrencyRateMutation) ClearField(name string) error {
	switch name {
	case currencyrate.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown CurrencyRate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CurrencyRateMutation) ResetField(name string) error {
	switch name {
	case currencyrate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case currencyrate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case currencyrate.FieldSymbol:
		m.ResetSymbol()
		return nil
	case currencyrate.FieldRate:
		m.ResetRate()
		return nil
	case currencyrate.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown CurrencyRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CurrencyRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CurrencyRateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CurrencyRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CurrencyRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CurrencyRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CurrencyRateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CurrencyRateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CurrencyRate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CurrencyRateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CurrencyRate edge %s", name)
}

// IcoMutation represents an operation that mutates the Ico nodes in the graph.
type IcoMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	round_id      *int32
	addround_id   *int32
	round_name    *string
	price         *string
	num_token     *string
	num_sub       *int32
	addnum_sub    *int32
	price_gap     *string
	ended_at      *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Ico, error)
	predicates    []predicate.Ico
}

var _ ent.Mutation = (*IcoMutation)(nil)

// icoOption allows management of the mutation configuration using functional options.
type icoOption func(*IcoMutation)

// newIcoMutation creates new mutation for the Ico entity.
func newIcoMutation(c config, op Op, opts ...icoOption) *IcoMutation {
	m := &IcoMutation{
		config:        c,
		op:            op,
		typ:           TypeIco,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIcoID sets the ID field of the mutation.
func withIcoID(id xid.ID) icoOption {
	return func(m *IcoMutation) {
		var (
			err   error
			once  sync.Once
			value *Ico
		)
		m.oldValue = func(ctx context.Context) (*Ico, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ico.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIco sets the old Ico of the mutation.
func withIco(node *Ico) icoOption {
	return func(m *IcoMutation) {
		m.oldValue = func(context.Context) (*Ico, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IcoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IcoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ico entities.
func (m *IcoMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IcoMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IcoMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ico.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IcoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IcoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IcoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IcoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IcoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IcoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRoundID sets the "round_id" field.
func (m *IcoMutation) SetRoundID(i int32) {
	m.round_id = &i
	m.addround_id = nil
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *IcoMutation) RoundID() (r int32, exists bool) {
	v := m.round_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldRoundID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// AddRoundID adds i to the "round_id" field.
func (m *IcoMutation) AddRoundID(i int32) {
	if m.addround_id != nil {
		*m.addround_id += i
	} else {
		m.addround_id = &i
	}
}

// AddedRoundID returns the value that was added to the "round_id" field in this mutation.
func (m *IcoMutation) AddedRoundID() (r int32, exists bool) {
	v := m.addround_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *IcoMutation) ResetRoundID() {
	m.round_id = nil
	m.addround_id = nil
}

// SetRoundName sets the "round_name" field.
func (m *IcoMutation) SetRoundName(s string) {
	m.round_name = &s
}

// RoundName returns the value of the "round_name" field in the mutation.
func (m *IcoMutation) RoundName() (r string, exists bool) {
	v := m.round_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundName returns the old "round_name" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldRoundName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundName: %w", err)
	}
	return oldValue.RoundName, nil
}

// ResetRoundName resets all changes to the "round_name" field.
func (m *IcoMutation) ResetRoundName() {
	m.round_name = nil
}

// SetPrice sets the "price" field.
func (m *IcoMutation) SetPrice(s string) {
	m.price = &s
}

// Price returns the value of the "price" field in the mutation.
func (m *IcoMutation) Price() (r string, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *IcoMutation) ResetPrice() {
	m.price = nil
}

// SetNumToken sets the "num_token" field.
func (m *IcoMutation) SetNumToken(s string) {
	m.num_token = &s
}

// NumToken returns the value of the "num_token" field in the mutation.
func (m *IcoMutation) NumToken() (r string, exists bool) {
	v := m.num_token
	if v == nil {
		return
	}
	return *v, true
}

// OldNumToken returns the old "num_token" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldNumToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumToken: %w", err)
	}
	return oldValue.NumToken, nil
}

// ResetNumToken resets all changes to the "num_token" field.
func (m *IcoMutation) ResetNumToken() {
	m.num_token = nil
}

// SetNumSub sets the "num_sub" field.
func (m *IcoMutation) SetNumSub(i int32) {
	m.num_sub = &i
	m.addnum_sub = nil
}

// NumSub returns the value of the "num_sub" field in the mutation.
func (m *IcoMutation) NumSub() (r int32, exists bool) {
	v := m.num_sub
	if v == nil {
		return
	}
	return *v, true
}

// OldNumSub returns the old "num_sub" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldNumSub(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumSub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumSub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumSub: %w", err)
	}
	return oldValue.NumSub, nil
}

// AddNumSub adds i to the "num_sub" field.
func (m *IcoMutation) AddNumSub(i int32) {
	if m.addnum_sub != nil {
		*m.addnum_sub += i
	} else {
		m.addnum_sub = &i
	}
}

// AddedNumSub returns the value that was added to the "num_sub" field in this mutation.
func (m *IcoMutation) AddedNumSub() (r int32, exists bool) {
	v := m.addnum_sub
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumSub resets all changes to the "num_sub" field.
func (m *IcoMutation) ResetNumSub() {
	m.num_sub = nil
	m.addnum_sub = nil
}

// SetPriceGap sets the "price_gap" field.
func (m *IcoMutation) SetPriceGap(s string) {
	m.price_gap = &s
}

// PriceGap returns the value of the "price_gap" field in the mutation.
func (m *IcoMutation) PriceGap() (r string, exists bool) {
	v := m.price_gap
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceGap returns the old "price_gap" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldPriceGap(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceGap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceGap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceGap: %w", err)
	}
	return oldValue.PriceGap, nil
}

// ResetPriceGap resets all changes to the "price_gap" field.
func (m *IcoMutation) ResetPriceGap() {
	m.price_gap = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *IcoMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *IcoMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Ico entity.
// If the Ico object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *IcoMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[ico.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *IcoMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[ico.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *IcoMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, ico.FieldEndedAt)
}

// Where appends a list predicates to the IcoMutation builder.
func (m *IcoMutation) Where(ps ...predicate.Ico) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IcoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IcoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ico, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IcoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IcoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ico).
func (m *IcoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IcoMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, ico.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ico.FieldUpdatedAt)
	}
	if m.round_id != nil {
		fields = append(fields, ico.FieldRoundID)
	}
	if m.round_name != nil {
		fields = append(fields, ico.FieldRoundName)
	}
	if m.price != nil {
		fields = append(fields, ico.FieldPrice)
	}
	if m.num_token != nil {
		fields = append(fields, ico.FieldNumToken)
	}
	if m.num_sub != nil {
		fields = append(fields, ico.FieldNumSub)
	}
	if m.price_gap != nil {
		fields = append(fields, ico.FieldPriceGap)
	}
	if m.ended_at != nil {
		fields = append(fields, ico.FieldEndedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IcoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ico.FieldCreatedAt:
		return m.CreatedAt()
	case ico.FieldUpdatedAt:
		return m.UpdatedAt()
	case ico.FieldRoundID:
		return m.RoundID()
	case ico.FieldRoundName:
		return m.RoundName()
	case ico.FieldPrice:
		return m.Price()
	case ico.FieldNumToken:
		return m.NumToken()
	case ico.FieldNumSub:
		return m.NumSub()
	case ico.FieldPriceGap:
		return m.PriceGap()
	case ico.FieldEndedAt:
		return m.EndedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IcoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ico.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ico.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ico.FieldRoundID:
		return m.OldRoundID(ctx)
	case ico.FieldRoundName:
		return m.OldRoundName(ctx)
	case ico.FieldPrice:
		return m.OldPrice(ctx)
	case ico.FieldNumToken:
		return m.OldNumToken(ctx)
	case ico.FieldNumSub:
		return m.OldNumSub(ctx)
	case ico.FieldPriceGap:
		return m.OldPriceGap(ctx)
	case ico.FieldEndedAt:
		return m.OldEndedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ico field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ico.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ico.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ico.FieldRoundID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case ico.FieldRoundName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundName(v)
		return nil
	case ico.FieldPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case ico.FieldNumToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumToken(v)
		return nil
	case ico.FieldNumSub:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumSub(v)
		return nil
	case ico.FieldPriceGap:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceGap(v)
		return nil
	case ico.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ico field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IcoMutation) AddedFields() []string {
	var fields []string
	if m.addround_id != nil {
		fields = append(fields, ico.FieldRoundID)
	}
	if m.addnum_sub != nil {
		fields = append(fields, ico.FieldNumSub)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IcoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ico.FieldRoundID:
		return m.AddedRoundID()
	case ico.FieldNumSub:
		return m.AddedNumSub()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ico.FieldRoundID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundID(v)
		return nil
	case ico.FieldNumSub:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumSub(v)
		return nil
	}
	return fmt.Errorf("unknown Ico numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IcoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ico.FieldEndedAt) {
		fields = append(fields, ico.FieldEndedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IcoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IcoMutation) ClearField(name string) error {
	switch name {
	case ico.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Ico nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IcoMutation) ResetField(name string) error {
	switch name {
	case ico.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ico.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ico.FieldRoundID:
		m.ResetRoundID()
		return nil
	case ico.FieldRoundName:
		m.ResetRoundName()
		return nil
	case ico.FieldPrice:
		m.ResetPrice()
		return nil
	case ico.FieldNumToken:
		m.ResetNumToken()
		return nil
	case ico.FieldNumSub:
		m.ResetNumSub()
		return nil
	case ico.FieldPriceGap:
		m.ResetPriceGap()
		return nil
	case ico.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	}
	return fmt.Errorf("unknown Ico field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IcoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IcoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IcoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IcoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IcoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IcoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IcoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ico unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IcoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ico edge %s", name)
}

// IcoCouponMutation represents an operation that mutates the IcoCoupon nodes in the graph.
type IcoCouponMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *string
	coupon        *string
	reward        *string
	cashback      *string
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IcoCoupon, error)
	predicates    []predicate.IcoCoupon
}

var _ ent.Mutation = (*IcoCouponMutation)(nil)

// icocouponOption allows management of the mutation configuration using functional options.
type icocouponOption func(*IcoCouponMutation)

// newIcoCouponMutation creates new mutation for the IcoCoupon entity.
func newIcoCouponMutation(c config, op Op, opts ...icocouponOption) *IcoCouponMutation {
	m := &IcoCouponMutation{
		config:        c,
		op:            op,
		typ:           TypeIcoCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIcoCouponID sets the ID field of the mutation.
func withIcoCouponID(id xid.ID) icocouponOption {
	return func(m *IcoCouponMutation) {
		var (
			err   error
			once  sync.Once
			value *IcoCoupon
		)
		m.oldValue = func(ctx context.Context) (*IcoCoupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IcoCoupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIcoCoupon sets the old IcoCoupon of the mutation.
func withIcoCoupon(node *IcoCoupon) icocouponOption {
	return func(m *IcoCouponMutation) {
		m.oldValue = func(context.Context) (*IcoCoupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IcoCouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IcoCouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IcoCoupon entities.
func (m *IcoCouponMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IcoCouponMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IcoCouponMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IcoCoupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IcoCouponMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IcoCouponMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IcoCoupon entity.
// If the IcoCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoCouponMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IcoCouponMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IcoCouponMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IcoCouponMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IcoCoupon entity.
// If the IcoCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoCouponMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IcoCouponMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *IcoCouponMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IcoCouponMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IcoCoupon entity.
// If the IcoCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoCouponMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IcoCouponMutation) ResetUserID() {
	m.user_id = nil
}

// SetCoupon sets the "coupon" field.
func (m *IcoCouponMutation) SetCoupon(s string) {
	m.coupon = &s
}

// Coupon returns the value of the "coupon" field in the mutation.
func (m *IcoCouponMutation) Coupon() (r string, exists bool) {
	v := m.coupon
	if v == nil {
		return
	}
	return *v, true
}

// OldCoupon returns the old "coupon" field's value of the IcoCoupon entity.
// If the IcoCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoCouponMutation) OldCoupon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoupon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoupon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoupon: %w", err)
	}
	return oldValue.Coupon, nil
}

// ResetCoupon resets all changes to the "coupon" field.
func (m *IcoCouponMutation) ResetCoupon() {
	m.coupon = nil
}

// SetReward sets the "reward" field.
func (m *IcoCouponMutation) SetReward(s string) {
	m.reward = &s
}

// Reward returns the value of the "reward" field in the mutation.
func (m *IcoCouponMutation) Reward() (r string, exists bool) {
	v := m.reward
	if v == nil {
		return
	}
	return *v, true
}

// OldReward returns the old "reward" field's value of the IcoCoupon entity.
// If the IcoCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoCouponMutation) OldReward(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReward is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReward requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReward: %w", err)
	}
	return oldValue.Reward, nil
}

// ResetReward resets all changes to the "reward" field.
func (m *IcoCouponMutation) ResetReward() {
	m.reward = nil
}

// SetCashback sets the "cashback" field.
func (m *IcoCouponMutation) SetCashback(s string) {
	m.cashback = &s
}

// Cashback returns the value of the "cashback" field in the mutation.
func (m *IcoCouponMutation) Cashback() (r string, exists bool) {
	v := m.cashback
	if v == nil {
		return
	}
	return *v, true
}

// OldCashback returns the old "cashback" field's value of the IcoCoupon entity.
// If the IcoCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoCouponMutation) OldCashback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashback: %w", err)
	}
	return oldValue.Cashback, nil
}

// ResetCashback resets all changes to the "cashback" field.
func (m *IcoCouponMutation) ResetCashback() {
	m.cashback = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IcoCouponMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IcoCouponMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IcoCoupon entity.
// If the IcoCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoCouponMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IcoCouponMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[icocoupon.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IcoCouponMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[icocoupon.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IcoCouponMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, icocoupon.FieldDeletedAt)
}

// Where appends a list predicates to the IcoCouponMutation builder.
func (m *IcoCouponMutation) Where(ps ...predicate.IcoCoupon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IcoCouponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IcoCouponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IcoCoupon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IcoCouponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IcoCouponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IcoCoupon).
func (m *IcoCouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IcoCouponMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, icocoupon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, icocoupon.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, icocoupon.FieldUserID)
	}
	if m.coupon != nil {
		fields = append(fields, icocoupon.FieldCoupon)
	}
	if m.reward != nil {
		fields = append(fields, icocoupon.FieldReward)
	}
	if m.cashback != nil {
		fields = append(fields, icocoupon.FieldCashback)
	}
	if m.deleted_at != nil {
		fields = append(fields, icocoupon.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IcoCouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case icocoupon.FieldCreatedAt:
		return m.CreatedAt()
	case icocoupon.FieldUpdatedAt:
		return m.UpdatedAt()
	case icocoupon.FieldUserID:
		return m.UserID()
	case icocoupon.FieldCoupon:
		return m.Coupon()
	case icocoupon.FieldReward:
		return m.Reward()
	case icocoupon.FieldCashback:
		return m.Cashback()
	case icocoupon.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IcoCouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case icocoupon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case icocoupon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case icocoupon.FieldUserID:
		return m.OldUserID(ctx)
	case icocoupon.FieldCoupon:
		return m.OldCoupon(ctx)
	case icocoupon.FieldReward:
		return m.OldReward(ctx)
	case icocoupon.FieldCashback:
		return m.OldCashback(ctx)
	case icocoupon.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IcoCoupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcoCouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case icocoupon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case icocoupon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case icocoupon.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case icocoupon.FieldCoupon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoupon(v)
		return nil
	case icocoupon.FieldReward:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReward(v)
		return nil
	case icocoupon.FieldCashback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashback(v)
		return nil
	case icocoupon.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IcoCoupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IcoCouponMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IcoCouponMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcoCouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IcoCoupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IcoCouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(icocoupon.FieldDeletedAt) {
		fields = append(fields, icocoupon.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IcoCouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IcoCouponMutation) ClearField(name string) error {
	switch name {
	case icocoupon.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown IcoCoupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IcoCouponMutation) ResetField(name string) error {
	switch name {
	case icocoupon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case icocoupon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case icocoupon.FieldUserID:
		m.ResetUserID()
		return nil
	case icocoupon.FieldCoupon:
		m.ResetCoupon()
		return nil
	case icocoupon.FieldReward:
		m.ResetReward()
		return nil
	case icocoupon.FieldCashback:
		m.ResetCashback()
		return nil
	case icocoupon.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown IcoCoupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IcoCouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IcoCouponMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IcoCouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IcoCouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IcoCouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IcoCouponMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IcoCouponMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IcoCoupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IcoCouponMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IcoCoupon edge %s", name)
}

// IcoHistoryMutation represents an operation that mutates the IcoHistory nodes in the graph.
type IcoHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	round_id      *int32
	addround_id   *int32
	user_id       *string
	price         *string
	num_token     *string
	sub_round     *int32
	addsub_round  *int32
	_type         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IcoHistory, error)
	predicates    []predicate.IcoHistory
}

var _ ent.Mutation = (*IcoHistoryMutation)(nil)

// icohistoryOption allows management of the mutation configuration using functional options.
type icohistoryOption func(*IcoHistoryMutation)

// newIcoHistoryMutation creates new mutation for the IcoHistory entity.
func newIcoHistoryMutation(c config, op Op, opts ...icohistoryOption) *IcoHistoryMutation {
	m := &IcoHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeIcoHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIcoHistoryID sets the ID field of the mutation.
func withIcoHistoryID(id xid.ID) icohistoryOption {
	return func(m *IcoHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *IcoHistory
		)
		m.oldValue = func(ctx context.Context) (*IcoHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IcoHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIcoHistory sets the old IcoHistory of the mutation.
func withIcoHistory(node *IcoHistory) icohistoryOption {
	return func(m *IcoHistoryMutation) {
		m.oldValue = func(context.Context) (*IcoHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IcoHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IcoHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IcoHistory entities.
func (m *IcoHistoryMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IcoHistoryMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IcoHistoryMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IcoHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IcoHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IcoHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IcoHistory entity.
// If the IcoHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IcoHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IcoHistoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IcoHistoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IcoHistory entity.
// If the IcoHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoHistoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IcoHistoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRoundID sets the "round_id" field.
func (m *IcoHistoryMutation) SetRoundID(i int32) {
	m.round_id = &i
	m.addround_id = nil
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *IcoHistoryMutation) RoundID() (r int32, exists bool) {
	v := m.round_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the IcoHistory entity.
// If the IcoHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoHistoryMutation) OldRoundID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// AddRoundID adds i to the "round_id" field.
func (m *IcoHistoryMutation) AddRoundID(i int32) {
	if m.addround_id != nil {
		*m.addround_id += i
	} else {
		m.addround_id = &i
	}
}

// AddedRoundID returns the value that was added to the "round_id" field in this mutation.
func (m *IcoHistoryMutation) AddedRoundID() (r int32, exists bool) {
	v := m.addround_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *IcoHistoryMutation) ResetRoundID() {
	m.round_id = nil
	m.addround_id = nil
}

// SetUserID sets the "user_id" field.
func (m *IcoHistoryMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IcoHistoryMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IcoHistory entity.
// If the IcoHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoHistoryMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IcoHistoryMutation) ResetUserID() {
	m.user_id = nil
}

// SetPrice sets the "price" field.
func (m *IcoHistoryMutation) SetPrice(s string) {
	m.price = &s
}

// Price returns the value of the "price" field in the mutation.
func (m *IcoHistoryMutation) Price() (r string, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the IcoHistory entity.
// If the IcoHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoHistoryMutation) OldPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *IcoHistoryMutation) ResetPrice() {
	m.price = nil
}

// SetNumToken sets the "num_token" field.
func (m *IcoHistoryMutation) SetNumToken(s string) {
	m.num_token = &s
}

// NumToken returns the value of the "num_token" field in the mutation.
func (m *IcoHistoryMutation) NumToken() (r string, exists bool) {
	v := m.num_token
	if v == nil {
		return
	}
	return *v, true
}

// OldNumToken returns the old "num_token" field's value of the IcoHistory entity.
// If the IcoHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoHistoryMutation) OldNumToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumToken: %w", err)
	}
	return oldValue.NumToken, nil
}

// ResetNumToken resets all changes to the "num_token" field.
func (m *IcoHistoryMutation) ResetNumToken() {
	m.num_token = nil
}

// SetSubRound sets the "sub_round" field.
func (m *IcoHistoryMutation) SetSubRound(i int32) {
	m.sub_round = &i
	m.addsub_round = nil
}

// SubRound returns the value of the "sub_round" field in the mutation.
func (m *IcoHistoryMutation) SubRound() (r int32, exists bool) {
	v := m.sub_round
	if v == nil {
		return
	}
	return *v, true
}

// OldSubRound returns the old "sub_round" field's value of the IcoHistory entity.
// If the IcoHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoHistoryMutation) OldSubRound(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubRound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubRound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubRound: %w", err)
	}
	return oldValue.SubRound, nil
}

// AddSubRound adds i to the "sub_round" field.
func (m *IcoHistoryMutation) AddSubRound(i int32) {
	if m.addsub_round != nil {
		*m.addsub_round += i
	} else {
		m.addsub_round = &i
	}
}

// AddedSubRound returns the value that was added to the "sub_round" field in this mutation.
func (m *IcoHistoryMutation) AddedSubRound() (r int32, exists bool) {
	v := m.addsub_round
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubRound resets all changes to the "sub_round" field.
func (m *IcoHistoryMutation) ResetSubRound() {
	m.sub_round = nil
	m.addsub_round = nil
}

// SetType sets the "type" field.
func (m *IcoHistoryMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *IcoHistoryMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the IcoHistory entity.
// If the IcoHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoHistoryMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *IcoHistoryMutation) ClearType() {
	m._type = nil
	m.clearedFields[icohistory.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *IcoHistoryMutation) TypeCleared() bool {
	_, ok := m.clearedFields[icohistory.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *IcoHistoryMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, icohistory.FieldType)
}

// Where appends a list predicates to the IcoHistoryMutation builder.
func (m *IcoHistoryMutation) Where(ps ...predicate.IcoHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IcoHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IcoHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IcoHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IcoHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IcoHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IcoHistory).
func (m *IcoHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IcoHistoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, icohistory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, icohistory.FieldUpdatedAt)
	}
	if m.round_id != nil {
		fields = append(fields, icohistory.FieldRoundID)
	}
	if m.user_id != nil {
		fields = append(fields, icohistory.FieldUserID)
	}
	if m.price != nil {
		fields = append(fields, icohistory.FieldPrice)
	}
	if m.num_token != nil {
		fields = append(fields, icohistory.FieldNumToken)
	}
	if m.sub_round != nil {
		fields = append(fields, icohistory.FieldSubRound)
	}
	if m._type != nil {
		fields = append(fields, icohistory.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IcoHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case icohistory.FieldCreatedAt:
		return m.CreatedAt()
	case icohistory.FieldUpdatedAt:
		return m.UpdatedAt()
	case icohistory.FieldRoundID:
		return m.RoundID()
	case icohistory.FieldUserID:
		return m.UserID()
	case icohistory.FieldPrice:
		return m.Price()
	case icohistory.FieldNumToken:
		return m.NumToken()
	case icohistory.FieldSubRound:
		return m.SubRound()
	case icohistory.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IcoHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case icohistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case icohistory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case icohistory.FieldRoundID:
		return m.OldRoundID(ctx)
	case icohistory.FieldUserID:
		return m.OldUserID(ctx)
	case icohistory.FieldPrice:
		return m.OldPrice(ctx)
	case icohistory.FieldNumToken:
		return m.OldNumToken(ctx)
	case icohistory.FieldSubRound:
		return m.OldSubRound(ctx)
	case icohistory.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown IcoHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcoHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case icohistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case icohistory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case icohistory.FieldRoundID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case icohistory.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case icohistory.FieldPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case icohistory.FieldNumToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumToken(v)
		return nil
	case icohistory.FieldSubRound:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubRound(v)
		return nil
	case icohistory.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown IcoHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IcoHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addround_id != nil {
		fields = append(fields, icohistory.FieldRoundID)
	}
	if m.addsub_round != nil {
		fields = append(fields, icohistory.FieldSubRound)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IcoHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case icohistory.FieldRoundID:
		return m.AddedRoundID()
	case icohistory.FieldSubRound:
		return m.AddedSubRound()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcoHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case icohistory.FieldRoundID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundID(v)
		return nil
	case icohistory.FieldSubRound:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubRound(v)
		return nil
	}
	return fmt.Errorf("unknown IcoHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IcoHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(icohistory.FieldType) {
		fields = append(fields, icohistory.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IcoHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IcoHistoryMutation) ClearField(name string) error {
	switch name {
	case icohistory.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown IcoHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IcoHistoryMutation) ResetField(name string) error {
	switch name {
	case icohistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case icohistory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case icohistory.FieldRoundID:
		m.ResetRoundID()
		return nil
	case icohistory.FieldUserID:
		m.ResetUserID()
		return nil
	case icohistory.FieldPrice:
		m.ResetPrice()
		return nil
	case icohistory.FieldNumToken:
		m.ResetNumToken()
		return nil
	case icohistory.FieldSubRound:
		m.ResetSubRound()
		return nil
	case icohistory.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown IcoHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IcoHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IcoHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IcoHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IcoHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IcoHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IcoHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IcoHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IcoHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IcoHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IcoHistory edge %s", name)
}

// IcoRoundMutation represents an operation that mutates the IcoRound nodes in the graph.
type IcoRoundMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	round_id      *int32
	addround_id   *int32
	sub_round     *int32
	addsub_round  *int32
	price         *string
	num_token     *string
	bought_token  *string
	start_at      *time.Time
	end_at        *time.Time
	is_close      *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*IcoRound, error)
	predicates    []predicate.IcoRound
}

var _ ent.Mutation = (*IcoRoundMutation)(nil)

// icoroundOption allows management of the mutation configuration using functional options.
type icoroundOption func(*IcoRoundMutation)

// newIcoRoundMutation creates new mutation for the IcoRound entity.
func newIcoRoundMutation(c config, op Op, opts ...icoroundOption) *IcoRoundMutation {
	m := &IcoRoundMutation{
		config:        c,
		op:            op,
		typ:           TypeIcoRound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIcoRoundID sets the ID field of the mutation.
func withIcoRoundID(id xid.ID) icoroundOption {
	return func(m *IcoRoundMutation) {
		var (
			err   error
			once  sync.Once
			value *IcoRound
		)
		m.oldValue = func(ctx context.Context) (*IcoRound, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IcoRound.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIcoRound sets the old IcoRound of the mutation.
func withIcoRound(node *IcoRound) icoroundOption {
	return func(m *IcoRoundMutation) {
		m.oldValue = func(context.Context) (*IcoRound, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IcoRoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IcoRoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IcoRound entities.
func (m *IcoRoundMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IcoRoundMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IcoRoundMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IcoRound.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IcoRoundMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IcoRoundMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IcoRoundMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IcoRoundMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IcoRoundMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IcoRoundMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRoundID sets the "round_id" field.
func (m *IcoRoundMutation) SetRoundID(i int32) {
	m.round_id = &i
	m.addround_id = nil
}

// RoundID returns the value of the "round_id" field in the mutation.
func (m *IcoRoundMutation) RoundID() (r int32, exists bool) {
	v := m.round_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoundID returns the old "round_id" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldRoundID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoundID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoundID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoundID: %w", err)
	}
	return oldValue.RoundID, nil
}

// AddRoundID adds i to the "round_id" field.
func (m *IcoRoundMutation) AddRoundID(i int32) {
	if m.addround_id != nil {
		*m.addround_id += i
	} else {
		m.addround_id = &i
	}
}

// AddedRoundID returns the value that was added to the "round_id" field in this mutation.
func (m *IcoRoundMutation) AddedRoundID() (r int32, exists bool) {
	v := m.addround_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoundID resets all changes to the "round_id" field.
func (m *IcoRoundMutation) ResetRoundID() {
	m.round_id = nil
	m.addround_id = nil
}

// SetSubRound sets the "sub_round" field.
func (m *IcoRoundMutation) SetSubRound(i int32) {
	m.sub_round = &i
	m.addsub_round = nil
}

// SubRound returns the value of the "sub_round" field in the mutation.
func (m *IcoRoundMutation) SubRound() (r int32, exists bool) {
	v := m.sub_round
	if v == nil {
		return
	}
	return *v, true
}

// OldSubRound returns the old "sub_round" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldSubRound(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubRound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubRound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubRound: %w", err)
	}
	return oldValue.SubRound, nil
}

// AddSubRound adds i to the "sub_round" field.
func (m *IcoRoundMutation) AddSubRound(i int32) {
	if m.addsub_round != nil {
		*m.addsub_round += i
	} else {
		m.addsub_round = &i
	}
}

// AddedSubRound returns the value that was added to the "sub_round" field in this mutation.
func (m *IcoRoundMutation) AddedSubRound() (r int32, exists bool) {
	v := m.addsub_round
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubRound resets all changes to the "sub_round" field.
func (m *IcoRoundMutation) ResetSubRound() {
	m.sub_round = nil
	m.addsub_round = nil
}

// SetPrice sets the "price" field.
func (m *IcoRoundMutation) SetPrice(s string) {
	m.price = &s
}

// Price returns the value of the "price" field in the mutation.
func (m *IcoRoundMutation) Price() (r string, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *IcoRoundMutation) ResetPrice() {
	m.price = nil
}

// SetNumToken sets the "num_token" field.
func (m *IcoRoundMutation) SetNumToken(s string) {
	m.num_token = &s
}

// NumToken returns the value of the "num_token" field in the mutation.
func (m *IcoRoundMutation) NumToken() (r string, exists bool) {
	v := m.num_token
	if v == nil {
		return
	}
	return *v, true
}

// OldNumToken returns the old "num_token" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldNumToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumToken: %w", err)
	}
	return oldValue.NumToken, nil
}

// ResetNumToken resets all changes to the "num_token" field.
func (m *IcoRoundMutation) ResetNumToken() {
	m.num_token = nil
}

// SetBoughtToken sets the "bought_token" field.
func (m *IcoRoundMutation) SetBoughtToken(s string) {
	m.bought_token = &s
}

// BoughtToken returns the value of the "bought_token" field in the mutation.
func (m *IcoRoundMutation) BoughtToken() (r string, exists bool) {
	v := m.bought_token
	if v == nil {
		return
	}
	return *v, true
}

// OldBoughtToken returns the old "bought_token" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldBoughtToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoughtToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoughtToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoughtToken: %w", err)
	}
	return oldValue.BoughtToken, nil
}

// ResetBoughtToken resets all changes to the "bought_token" field.
func (m *IcoRoundMutation) ResetBoughtToken() {
	m.bought_token = nil
}

// SetStartAt sets the "start_at" field.
func (m *IcoRoundMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *IcoRoundMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *IcoRoundMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[icoround.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *IcoRoundMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[icoround.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *IcoRoundMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, icoround.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *IcoRoundMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *IcoRoundMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *IcoRoundMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[icoround.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *IcoRoundMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[icoround.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *IcoRoundMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, icoround.FieldEndAt)
}

// SetIsClose sets the "is_close" field.
func (m *IcoRoundMutation) SetIsClose(b bool) {
	m.is_close = &b
}

// IsClose returns the value of the "is_close" field in the mutation.
func (m *IcoRoundMutation) IsClose() (r bool, exists bool) {
	v := m.is_close
	if v == nil {
		return
	}
	return *v, true
}

// OldIsClose returns the old "is_close" field's value of the IcoRound entity.
// If the IcoRound object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IcoRoundMutation) OldIsClose(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsClose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsClose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsClose: %w", err)
	}
	return oldValue.IsClose, nil
}

// ResetIsClose resets all changes to the "is_close" field.
func (m *IcoRoundMutation) ResetIsClose() {
	m.is_close = nil
}

// Where appends a list predicates to the IcoRoundMutation builder.
func (m *IcoRoundMutation) Where(ps ...predicate.IcoRound) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IcoRoundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IcoRoundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IcoRound, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IcoRoundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IcoRoundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IcoRound).
func (m *IcoRoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IcoRoundMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, icoround.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, icoround.FieldUpdatedAt)
	}
	if m.round_id != nil {
		fields = append(fields, icoround.FieldRoundID)
	}
	if m.sub_round != nil {
		fields = append(fields, icoround.FieldSubRound)
	}
	if m.price != nil {
		fields = append(fields, icoround.FieldPrice)
	}
	if m.num_token != nil {
		fields = append(fields, icoround.FieldNumToken)
	}
	if m.bought_token != nil {
		fields = append(fields, icoround.FieldBoughtToken)
	}
	if m.start_at != nil {
		fields = append(fields, icoround.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, icoround.FieldEndAt)
	}
	if m.is_close != nil {
		fields = append(fields, icoround.FieldIsClose)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IcoRoundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case icoround.FieldCreatedAt:
		return m.CreatedAt()
	case icoround.FieldUpdatedAt:
		return m.UpdatedAt()
	case icoround.FieldRoundID:
		return m.RoundID()
	case icoround.FieldSubRound:
		return m.SubRound()
	case icoround.FieldPrice:
		return m.Price()
	case icoround.FieldNumToken:
		return m.NumToken()
	case icoround.FieldBoughtToken:
		return m.BoughtToken()
	case icoround.FieldStartAt:
		return m.StartAt()
	case icoround.FieldEndAt:
		return m.EndAt()
	case icoround.FieldIsClose:
		return m.IsClose()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IcoRoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case icoround.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case icoround.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case icoround.FieldRoundID:
		return m.OldRoundID(ctx)
	case icoround.FieldSubRound:
		return m.OldSubRound(ctx)
	case icoround.FieldPrice:
		return m.OldPrice(ctx)
	case icoround.FieldNumToken:
		return m.OldNumToken(ctx)
	case icoround.FieldBoughtToken:
		return m.OldBoughtToken(ctx)
	case icoround.FieldStartAt:
		return m.OldStartAt(ctx)
	case icoround.FieldEndAt:
		return m.OldEndAt(ctx)
	case icoround.FieldIsClose:
		return m.OldIsClose(ctx)
	}
	return nil, fmt.Errorf("unknown IcoRound field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcoRoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case icoround.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case icoround.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case icoround.FieldRoundID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoundID(v)
		return nil
	case icoround.FieldSubRound:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubRound(v)
		return nil
	case icoround.FieldPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case icoround.FieldNumToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumToken(v)
		return nil
	case icoround.FieldBoughtToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoughtToken(v)
		return nil
	case icoround.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case icoround.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case icoround.FieldIsClose:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsClose(v)
		return nil
	}
	return fmt.Errorf("unknown IcoRound field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IcoRoundMutation) AddedFields() []string {
	var fields []string
	if m.addround_id != nil {
		fields = append(fields, icoround.FieldRoundID)
	}
	if m.addsub_round != nil {
		fields = append(fields, icoround.FieldSubRound)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IcoRoundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case icoround.FieldRoundID:
		return m.AddedRoundID()
	case icoround.FieldSubRound:
		return m.AddedSubRound()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IcoRoundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case icoround.FieldRoundID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoundID(v)
		return nil
	case icoround.FieldSubRound:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubRound(v)
		return nil
	}
	return fmt.Errorf("unknown IcoRound numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IcoRoundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(icoround.FieldStartAt) {
		fields = append(fields, icoround.FieldStartAt)
	}
	if m.FieldCleared(icoround.FieldEndAt) {
		fields = append(fields, icoround.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IcoRoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IcoRoundMutation) ClearField(name string) error {
	switch name {
	case icoround.FieldStartAt:
		m.ClearStartAt()
		return nil
	case icoround.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown IcoRound nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IcoRoundMutation) ResetField(name string) error {
	switch name {
	case icoround.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case icoround.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case icoround.FieldRoundID:
		m.ResetRoundID()
		return nil
	case icoround.FieldSubRound:
		m.ResetSubRound()
		return nil
	case icoround.FieldPrice:
		m.ResetPrice()
		return nil
	case icoround.FieldNumToken:
		m.ResetNumToken()
		return nil
	case icoround.FieldBoughtToken:
		m.ResetBoughtToken()
		return nil
	case icoround.FieldStartAt:
		m.ResetStartAt()
		return nil
	case icoround.FieldEndAt:
		m.ResetEndAt()
		return nil
	case icoround.FieldIsClose:
		m.ResetIsClose()
		return nil
	}
	return fmt.Errorf("unknown IcoRound field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IcoRoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IcoRoundMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IcoRoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IcoRoundMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IcoRoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IcoRoundMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IcoRoundMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown IcoRound unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IcoRoundMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown IcoRound edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	created_at     *time.Time
	updated_at     *time.Time
	trans_type     *string
	source         *string
	src_symbol     *string
	src_amount     *string
	destination    *string
	dest_symbol    *string
	dest_amount    *string
	rate           *string
	source_service *string
	source_id      *string
	status         *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Transaction, error)
	predicates     []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id xid.ID) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transaction entities.
func (m *TransactionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TransactionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TransactionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TransactionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTransType sets the "trans_type" field.
func (m *TransactionMutation) SetTransType(s string) {
	m.trans_type = &s
}

// TransType returns the value of the "trans_type" field in the mutation.
func (m *TransactionMutation) TransType() (r string, exists bool) {
	v := m.trans_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransType returns the old "trans_type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldTransType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransType: %w", err)
	}
	return oldValue.TransType, nil
}

// ResetTransType resets all changes to the "trans_type" field.
func (m *TransactionMutation) ResetTransType() {
	m.trans_type = nil
}

// SetSource sets the "source" field.
func (m *TransactionMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TransactionMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TransactionMutation) ResetSource() {
	m.source = nil
}

// SetSrcSymbol sets the "src_symbol" field.
func (m *TransactionMutation) SetSrcSymbol(s string) {
	m.src_symbol = &s
}

// SrcSymbol returns the value of the "src_symbol" field in the mutation.
func (m *TransactionMutation) SrcSymbol() (r string, exists bool) {
	v := m.src_symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSrcSymbol returns the old "src_symbol" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldSrcSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrcSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrcSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrcSymbol: %w", err)
	}
	return oldValue.SrcSymbol, nil
}

// ResetSrcSymbol resets all changes to the "src_symbol" field.
func (m *TransactionMutation) ResetSrcSymbol() {
	m.src_symbol = nil
}

// SetSrcAmount sets the "src_amount" field.
func (m *TransactionMutation) SetSrcAmount(s string) {
	m.src_amount = &s
}

// SrcAmount returns the value of the "src_amount" field in the mutation.
func (m *TransactionMutation) SrcAmount() (r string, exists bool) {
	v := m.src_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSrcAmount returns the old "src_amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldSrcAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrcAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrcAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrcAmount: %w", err)
	}
	return oldValue.SrcAmount, nil
}

// ResetSrcAmount resets all changes to the "src_amount" field.
func (m *TransactionMutation) ResetSrcAmount() {
	m.src_amount = nil
}

// SetDestination sets the "destination" field.
func (m *TransactionMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *TransactionMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *TransactionMutation) ResetDestination() {
	m.destination = nil
}

// SetDestSymbol sets the "dest_symbol" field.
func (m *TransactionMutation) SetDestSymbol(s string) {
	m.dest_symbol = &s
}

// DestSymbol returns the value of the "dest_symbol" field in the mutation.
func (m *TransactionMutation) DestSymbol() (r string, exists bool) {
	v := m.dest_symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldDestSymbol returns the old "dest_symbol" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDestSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestSymbol: %w", err)
	}
	return oldValue.DestSymbol, nil
}

// ResetDestSymbol resets all changes to the "dest_symbol" field.
func (m *TransactionMutation) ResetDestSymbol() {
	m.dest_symbol = nil
}

// SetDestAmount sets the "dest_amount" field.
func (m *TransactionMutation) SetDestAmount(s string) {
	m.dest_amount = &s
}

// DestAmount returns the value of the "dest_amount" field in the mutation.
func (m *TransactionMutation) DestAmount() (r string, exists bool) {
	v := m.dest_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDestAmount returns the old "dest_amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDestAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestAmount: %w", err)
	}
	return oldValue.DestAmount, nil
}

// ResetDestAmount resets all changes to the "dest_amount" field.
func (m *TransactionMutation) ResetDestAmount() {
	m.dest_amount = nil
}

// SetRate sets the "rate" field.
func (m *TransactionMutation) SetRate(s string) {
	m.rate = &s
}

// Rate returns the value of the "rate" field in the mutation.
func (m *TransactionMutation) Rate() (r string, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// ResetRate resets all changes to the "rate" field.
func (m *TransactionMutation) ResetRate() {
	m.rate = nil
}

// SetSourceService sets the "source_service" field.
func (m *TransactionMutation) SetSourceService(s string) {
	m.source_service = &s
}

// SourceService returns the value of the "source_service" field in the mutation.
func (m *TransactionMutation) SourceService() (r string, exists bool) {
	v := m.source_service
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceService returns the old "source_service" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldSourceService(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceService: %w", err)
	}
	return oldValue.SourceService, nil
}

// ResetSourceService resets all changes to the "source_service" field.
func (m *TransactionMutation) ResetSourceService() {
	m.source_service = nil
}

// SetSourceID sets the "source_id" field.
func (m *TransactionMutation) SetSourceID(s string) {
	m.source_id = &s
}

// SourceID returns the value of the "source_id" field in the mutation.
func (m *TransactionMutation) SourceID() (r string, exists bool) {
	v := m.source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceID returns the old "source_id" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldSourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceID: %w", err)
	}
	return oldValue.SourceID, nil
}

// ResetSourceID resets all changes to the "source_id" field.
func (m *TransactionMutation) ResetSourceID() {
	m.source_id = nil
}

// SetStatus sets the "status" field.
func (m *TransactionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TransactionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransactionMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, transaction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, transaction.FieldUpdatedAt)
	}
	if m.trans_type != nil {
		fields = append(fields, transaction.FieldTransType)
	}
	if m.source != nil {
		fields = append(fields, transaction.FieldSource)
	}
	if m.src_symbol != nil {
		fields = append(fields, transaction.FieldSrcSymbol)
	}
	if m.src_amount != nil {
		fields = append(fields, transaction.FieldSrcAmount)
	}
	if m.destination != nil {
		fields = append(fields, transaction.FieldDestination)
	}
	if m.dest_symbol != nil {
		fields = append(fields, transaction.FieldDestSymbol)
	}
	if m.dest_amount != nil {
		fields = append(fields, transaction.FieldDestAmount)
	}
	if m.rate != nil {
		fields = append(fields, transaction.FieldRate)
	}
	if m.source_service != nil {
		fields = append(fields, transaction.FieldSourceService)
	}
	if m.source_id != nil {
		fields = append(fields, transaction.FieldSourceID)
	}
	if m.status != nil {
		fields = append(fields, transaction.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.CreatedAt()
	case transaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case transaction.FieldTransType:
		return m.TransType()
	case transaction.FieldSource:
		return m.Source()
	case transaction.FieldSrcSymbol:
		return m.SrcSymbol()
	case transaction.FieldSrcAmount:
		return m.SrcAmount()
	case transaction.FieldDestination:
		return m.Destination()
	case transaction.FieldDestSymbol:
		return m.DestSymbol()
	case transaction.FieldDestAmount:
		return m.DestAmount()
	case transaction.FieldRate:
		return m.Rate()
	case transaction.FieldSourceService:
		return m.SourceService()
	case transaction.FieldSourceID:
		return m.SourceID()
	case transaction.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case transaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case transaction.FieldTransType:
		return m.OldTransType(ctx)
	case transaction.FieldSource:
		return m.OldSource(ctx)
	case transaction.FieldSrcSymbol:
		return m.OldSrcSymbol(ctx)
	case transaction.FieldSrcAmount:
		return m.OldSrcAmount(ctx)
	case transaction.FieldDestination:
		return m.OldDestination(ctx)
	case transaction.FieldDestSymbol:
		return m.OldDestSymbol(ctx)
	case transaction.FieldDestAmount:
		return m.OldDestAmount(ctx)
	case transaction.FieldRate:
		return m.OldRate(ctx)
	case transaction.FieldSourceService:
		return m.OldSourceService(ctx)
	case transaction.FieldSourceID:
		return m.OldSourceID(ctx)
	case transaction.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case transaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case transaction.FieldTransType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransType(v)
		return nil
	case transaction.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case transaction.FieldSrcSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrcSymbol(v)
		return nil
	case transaction.FieldSrcAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrcAmount(v)
		return nil
	case transaction.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case transaction.FieldDestSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestSymbol(v)
		return nil
	case transaction.FieldDestAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestAmount(v)
		return nil
	case transaction.FieldRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case transaction.FieldSourceService:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceService(v)
		return nil
	case transaction.FieldSourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceID(v)
		return nil
	case transaction.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case transaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case transaction.FieldTransType:
		m.ResetTransType()
		return nil
	case transaction.FieldSource:
		m.ResetSource()
		return nil
	case transaction.FieldSrcSymbol:
		m.ResetSrcSymbol()
		return nil
	case transaction.FieldSrcAmount:
		m.ResetSrcAmount()
		return nil
	case transaction.FieldDestination:
		m.ResetDestination()
		return nil
	case transaction.FieldDestSymbol:
		m.ResetDestSymbol()
		return nil
	case transaction.FieldDestAmount:
		m.ResetDestAmount()
		return nil
	case transaction.FieldRate:
		m.ResetRate()
		return nil
	case transaction.FieldSourceService:
		m.ResetSourceService()
		return nil
	case transaction.FieldSourceID:
		m.ResetSourceID()
		return nil
	case transaction.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Transaction edge %s", name)
}

// UserWalletMutation represents an operation that mutates the UserWallet nodes in the graph.
type UserWalletMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *string
	_type         *string
	symbol        *string
	is_active     *bool
	balance       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserWallet, error)
	predicates    []predicate.UserWallet
}

var _ ent.Mutation = (*UserWalletMutation)(nil)

// userwalletOption allows management of the mutation configuration using functional options.
type userwalletOption func(*UserWalletMutation)

// newUserWalletMutation creates new mutation for the UserWallet entity.
func newUserWalletMutation(c config, op Op, opts ...userwalletOption) *UserWalletMutation {
	m := &UserWalletMutation{
		config:        c,
		op:            op,
		typ:           TypeUserWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserWalletID sets the ID field of the mutation.
func withUserWalletID(id xid.ID) userwalletOption {
	return func(m *UserWalletMutation) {
		var (
			err   error
			once  sync.Once
			value *UserWallet
		)
		m.oldValue = func(ctx context.Context) (*UserWallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserWallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserWallet sets the old UserWallet of the mutation.
func withUserWallet(node *UserWallet) userwalletOption {
	return func(m *UserWalletMutation) {
		m.oldValue = func(context.Context) (*UserWallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserWalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserWalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserWallet entities.
func (m *UserWalletMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserWalletMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserWalletMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserWallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserWalletMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserWalletMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserWalletMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserWalletMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserWalletMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserWalletMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserWalletMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserWalletMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserWalletMutation) ResetUserID() {
	m.user_id = nil
}

// SetType sets the "type" field.
func (m *UserWalletMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserWalletMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserWalletMutation) ResetType() {
	m._type = nil
}

// SetSymbol sets the "symbol" field.
func (m *UserWalletMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *UserWalletMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *UserWalletMutation) ResetSymbol() {
	m.symbol = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserWalletMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserWalletMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserWalletMutation) ResetIsActive() {
	m.is_active = nil
}

// SetBalance sets the "balance" field.
func (m *UserWalletMutation) SetBalance(s string) {
	m.balance = &s
}

// Balance returns the value of the "balance" field in the mutation.
func (m *UserWalletMutation) Balance() (r string, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldBalance(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// ResetBalance resets all changes to the "balance" field.
func (m *UserWalletMutation) ResetBalance() {
	m.balance = nil
}

// Where appends a list predicates to the UserWalletMutation builder.
func (m *UserWalletMutation) Where(ps ...predicate.UserWallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserWalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserWalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserWallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserWalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserWalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserWallet).
func (m *UserWalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserWalletMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, userwallet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userwallet.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, userwallet.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, userwallet.FieldType)
	}
	if m.symbol != nil {
		fields = append(fields, userwallet.FieldSymbol)
	}
	if m.is_active != nil {
		fields = append(fields, userwallet.FieldIsActive)
	}
	if m.balance != nil {
		fields = append(fields, userwallet.FieldBalance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserWalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userwallet.FieldCreatedAt:
		return m.CreatedAt()
	case userwallet.FieldUpdatedAt:
		return m.UpdatedAt()
	case userwallet.FieldUserID:
		return m.UserID()
	case userwallet.FieldType:
		return m.GetType()
	case userwallet.FieldSymbol:
		return m.Symbol()
	case userwallet.FieldIsActive:
		return m.IsActive()
	case userwallet.FieldBalance:
		return m.Balance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserWalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userwallet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userwallet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userwallet.FieldUserID:
		return m.OldUserID(ctx)
	case userwallet.FieldType:
		return m.OldType(ctx)
	case userwallet.FieldSymbol:
		return m.OldSymbol(ctx)
	case userwallet.FieldIsActive:
		return m.OldIsActive(ctx)
	case userwallet.FieldBalance:
		return m.OldBalance(ctx)
	}
	return nil, fmt.Errorf("unknown UserWallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserWalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userwallet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userwallet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userwallet.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userwallet.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case userwallet.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case userwallet.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case userwallet.FieldBalance:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	}
	return fmt.Errorf("unknown UserWallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserWalletMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserWalletMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserWalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserWallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserWalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserWalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserWalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserWallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserWalletMutation) ResetField(name string) error {
	switch name {
	case userwallet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userwallet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userwallet.FieldUserID:
		m.ResetUserID()
		return nil
	case userwallet.FieldType:
		m.ResetType()
		return nil
	case userwallet.FieldSymbol:
		m.ResetSymbol()
		return nil
	case userwallet.FieldIsActive:
		m.ResetIsActive()
		return nil
	case userwallet.FieldBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown UserWallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserWalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserWalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserWalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserWalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserWalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserWalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserWalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserWallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserWalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserWallet edge %s", name)
}
